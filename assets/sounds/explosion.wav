"""
Audio Manager and Sound Effects System.

This module provides a robust audio management system with support for sound effects
and background music, with specific handling for explosion sounds.

Author: Senior Developer
Created: 2025-01-20
"""

import asyncio
import logging
import os
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, Optional, Union
from contextlib import contextmanager
import time
import wave

try:
    import pyaudio
    import numpy as np
except ImportError as e:
    logging.error(f"Required audio dependencies not found: {e}")
    raise

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class AudioError(Exception):
    """Base exception class for audio-related errors."""
    pass

class AudioFileNotFoundError(AudioError):
    """Raised when an audio file cannot be found."""
    pass

class AudioFormat(Enum):
    """Supported audio format types."""
    WAV = "wav"
    MP3 = "mp3"
    OGG = "ogg"

@dataclass
class AudioConfig:
    """Configuration settings for audio playback."""
    sample_rate: int = 44100
    channels: int = 2
    chunk_size: int = 1024
    format: int = pyaudio.paFloat32
    volume: float = 1.0

class AudioManager:
    """
    Manages audio playback and sound effects.
    
    Handles loading, playing, and managing audio resources with proper resource
    management and error handling.
    """

    def __init__(self, config: Optional[AudioConfig] = None):
        """Initialize the AudioManager with optional configuration."""
        self.config = config or AudioConfig()
        self._audio_interface = pyaudio.PyAudio()
        self._cache: Dict[str, np.ndarray] = {}
        self._current_streams: Dict[int, pyaudio.Stream] = {}
        self._is_initialized = False
        
        try:
            self._initialize()
        except Exception as e:
            logger.error(f"Failed to initialize AudioManager: {e}")
            raise AudioError(f"Audio initialization failed: {e}")

    def _initialize(self) -> None:
        """Initialize audio system and verify resources."""
        logger.info("Initializing AudioManager...")
        self._verify_audio_directory()
        self._is_initialized = True

    @staticmethod
    def _verify_audio_directory() -> None:
        """Verify that the audio directory exists and is accessible."""
        audio_path = Path("assets/sounds")
        if not audio_path.exists():
            logger.error("Audio directory not found")
            raise AudioFileNotFoundError("Audio directory does not exist")

    async def load_sound(self, file_path: Union[str, Path]) -> np.ndarray:
        """
        Load a sound file into memory.
        
        Args:
            file_path: Path to the sound file
            
        Returns:
            numpy.ndarray: Audio data
            
        Raises:
            AudioFileNotFoundError: If the file doesn't exist
            AudioError: If there's an error loading the file
        """
        path = Path(file_path)
        if not path.exists():
            raise AudioFileNotFoundError(f"Sound file not found: {path}")

        try:
            with wave.open(str(path), 'rb') as wave_file:
                audio_data = np.frombuffer(
                    wave_file.readframes(wave_file.getnframes()),
                    dtype=np.float32
                )
                return audio_data
        except Exception as e:
            logger.error(f"Failed to load sound file {path}: {e}")
            raise AudioError(f"Error loading sound file: {e}")

    async def play_explosion(self) -> None:
        """
        Play the explosion sound effect.
        
        Raises:
            AudioError: If there's an error playing the sound
        """
        try:
            explosion_path = Path("assets/sounds/explosion.wav")
            audio_data = await self.load_sound(explosion_path)
            
            stream = self._audio_interface.open(
                format=self.config.format,
                channels=self.config.channels,
                rate=self.config.sample_rate,
                output=True
            )
            
            # Apply volume
            audio_data = audio_data * self.config.volume
            
            stream.write(audio_data.tobytes())
            stream.stop_stream()
            stream.close()
            
            logger.debug("Explosion sound effect played successfully")
        except Exception as e:
            logger.error(f"Failed to play explosion sound: {e}")
            raise AudioError(f"Error playing explosion sound: {e}")

    @contextmanager
    def resource_context(self):
        """Context manager for handling audio resources."""
        try:
            yield self
        finally:
            self.cleanup()

    def cleanup(self) -> None:
        """Clean up audio resources."""
        try:
            for stream in self._current_streams.values():
                stream.stop_stream()
                stream.close()
            self._current_streams.clear()
            self._audio_interface.terminate()
            logger.info("Audio resources cleaned up successfully")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

    def __del__(self):
        """Ensure resources are properly cleaned up."""
        self.cleanup()

async def main():
    """Main function for testing the AudioManager."""
    async with AudioManager().resource_context() as audio_manager:
        await audio_manager.play_explosion()

if __name__ == "__main__":
    asyncio.run(main())