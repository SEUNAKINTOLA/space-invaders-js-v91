"""
Audio Management System
----------------------
A robust audio management system for handling background music and sound effects.

This module provides a thread-safe, resource-efficient audio manager with support for
background music playback, sound effects, and volume control.

Author: Senior Developer
Created: 2025-01-20
"""

import asyncio
import logging
import threading
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, Optional, Union
from contextlib import contextmanager
import time
from concurrent.futures import ThreadPoolExecutor

# Third-party imports (need to be added to requirements.txt)
import pygame.mixer
import pygame.error

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class AudioError(Exception):
    """Base exception class for audio-related errors."""
    pass

class AudioInitializationError(AudioError):
    """Raised when audio system initialization fails."""
    pass

class AudioFileError(AudioError):
    """Raised when audio file operations fail."""
    pass

class AudioState(Enum):
    """Enumeration of possible audio system states."""
    UNINITIALIZED = "uninitialized"
    READY = "ready"
    PLAYING = "playing"
    PAUSED = "paused"
    ERROR = "error"

@dataclass(frozen=True)
class AudioConfig:
    """Configuration settings for audio playback."""
    frequency: int = 44100
    size: int = -16
    channels: int = 2
    buffer: int = 2048
    max_volume: float = 1.0
    fade_ms: int = 1000

class AudioManager:
    """
    Thread-safe audio management system supporting background music and sound effects.
    
    Features:
    - Async support for non-blocking audio operations
    - Resource management with context managers
    - Comprehensive error handling
    - Volume control with fade effects
    """
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance

    def __init__(self):
        if not hasattr(self, '_initialized'):
            self._initialized = False
            self._state = AudioState.UNINITIALIZED
            self._config = AudioConfig()
            self._current_music: Optional[Path] = None
            self._volume = 1.0
            self._sound_effects: Dict[str, pygame.mixer.Sound] = {}
            self._executor = ThreadPoolExecutor(max_workers=2)
            self._initialize_audio_system()

    def _initialize_audio_system(self) -> None:
        """Initialize the pygame audio system with error handling."""
        try:
            pygame.mixer.init(
                frequency=self._config.frequency,
                size=self._config.size,
                channels=self._config.channels,
                buffer=self._config.buffer
            )
            self._initialized = True
            self._state = AudioState.READY
            logger.info("Audio system initialized successfully")
        except pygame.error as e:
            self._state = AudioState.ERROR
            raise AudioInitializationError(f"Failed to initialize audio system: {e}")

    @contextmanager
    def audio_context(self):
        """Context manager for ensuring proper audio system cleanup."""
        try:
            yield self
        finally:
            self.cleanup()

    async def load_background_music(self, file_path: Union[str, Path]) -> None:
        """
        Asynchronously load background music file.
        
        Args:
            file_path: Path to the audio file
            
        Raises:
            AudioFileError: If the file cannot be loaded
        """
        path = Path(file_path)
        if not path.exists():
            raise AudioFileError(f"Audio file not found: {path}")

        try:
            await asyncio.get_event_loop().run_in_executor(
                self._executor,
                pygame.mixer.music.load,
                str(path)
            )
            self._current_music = path
            logger.debug(f"Loaded background music: {path}")
        except pygame.error as e:
            raise AudioFileError(f"Failed to load audio file {path}: {e}")

    async def play_background_music(self, loops: int = -1, fade_ms: int = None) -> None:
        """
        Play background music with optional fade-in effect.
        
        Args:
            loops: Number of times to loop (-1 for infinite)
            fade_ms: Fade-in duration in milliseconds
        """
        if not self._initialized:
            raise AudioError("Audio system not initialized")

        fade_duration = fade_ms or self._config.fade_ms
        try:
            await asyncio.get_event_loop().run_in_executor(
                self._executor,
                lambda: pygame.mixer.music.play(loops, fade_ms=fade_duration)
            )
            self._state = AudioState.PLAYING
            logger.info(f"Playing background music: {self._current_music}")
        except pygame.error as e:
            raise AudioError(f"Failed to play background music: {e}")

    def set_volume(self, volume: float) -> None:
        """
        Set the master volume level.
        
        Args:
            volume: Volume level between 0.0 and 1.0
        """
        self._volume = max(0.0, min(volume, self._config.max_volume))
        pygame.mixer.music.set_volume(self._volume)
        logger.debug(f"Volume set to: {self._volume}")

    def pause(self) -> None:
        """Pause background music playback."""
        if self._state == AudioState.PLAYING:
            pygame.mixer.music.pause()
            self._state = AudioState.PAUSED
            logger.debug("Background music paused")

    def resume(self) -> None:
        """Resume background music playback."""
        if self._state == AudioState.PAUSED:
            pygame.mixer.music.unpause()
            self._state = AudioState.PLAYING
            logger.debug("Background music resumed")

    def stop(self) -> None:
        """Stop background music playback."""
        pygame.mixer.music.stop()
        self._state = AudioState.READY
        logger.debug("Background music stopped")

    def cleanup(self) -> None:
        """Clean up audio system resources."""
        try:
            self.stop()
            pygame.mixer.quit()
            self._executor.shutdown(wait=True)
            self._initialized = False
            self._state = AudioState.UNINITIALIZED
            logger.info("Audio system cleaned up")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

    @property
    def state(self) -> AudioState:
        """Get current audio system state."""
        return self._state

    @property
    def volume(self) -> float:
        """Get current volume level."""
        return self._volume

    def __del__(self):
        """Ensure cleanup on object destruction."""
        self.cleanup()